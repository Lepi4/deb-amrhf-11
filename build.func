#!/usr/bin/env bash
# Minimal build helper inspired by community-scripts/ProxmoxVE (MIT)
# Tailored for WB Bullseye armhf LXC creation.

set -Eeuo pipefail

# ---------- UI helpers ----------
INFO="[i]"; OK="[ok]"; ERR="[err]"; WARN="[warn]"

msg_info(){ echo -e "${INFO} $*" >&2; }
msg_ok(){ echo -e "${OK} $*" >&2; }
msg_err(){ echo -e "${ERR} $*" >&2; }
msg_warn(){ echo -e "${WARN} $*" >&2; }

header_info(){ clear; echo "=== $1 LXC Builder (WB) ==="; }

# ---------- SSH Key Management ----------
SSH_KEYS_FILE=""
SSH_ENABLED="no"

ssh_extract_keys_from_file() {
  local f="$1"
  [[ -r "$f" ]] || return 0
  tr -d '\r' <"$f" | awk '
    /^[[:space:]]*#/ {next}
    /^[[:space:]]*$/ {next}
    /^(ssh-(rsa|ed25519)|ecdsa-sha2-nistp256|sk-(ssh-ed25519|ecdsa-sha2-nistp256))[[:space:]]+/ {print; next}
    {
      match($0, /(ssh-(rsa|ed25519)|ecdsa-sha2-nistp256|sk-(ssh-ed25519|ecdsa-sha2-nistp256))[[:space:]]+/)
      if (RSTART>0) { print substr($0, RSTART) }
    }
  '
}

find_ssh_keys() {
  local -a cand=()
  local re='(ssh-(rsa|ed25519)|ecdsa-sha2-nistp256|sk-(ssh-ed25519|ecdsa-sha2-nistp256))'
  
  shopt -s nullglob
  cand+=(/root/.ssh/authorized_keys /root/.ssh/authorized_keys2)
  cand+=(/root/.ssh/*.pub)
  cand+=(/etc/ssh/authorized_keys)
  shopt -u nullglob
  
  local -a files=()
  local total=0
  
  for f in "${cand[@]}"; do
    [[ -f "$f" && -r "$f" ]] || continue
    local base="$(basename -- "$f")"
    
    case "$base" in
      known_hosts|known_hosts.*|config) continue ;;
      id_*) [[ "$f" != *.pub ]] && continue ;;
    esac
    
    local c=$(tr -d '\r' <"$f" | awk '/^[[:space:]]*#/ {next} /^[[:space:]]*$/ {next} {print}' | grep -E -c "$re" || true)
    
    if ((c > 0)); then
      files+=("$f")
      total=$((total + c))
    fi
  done
  
  if ((${#files[@]} == 0)) && [[ -r /root/.ssh/authorized_keys ]]; then
    if grep -E -q "$re" /root/.ssh/authorized_keys; then
      files+=(/root/.ssh/authorized_keys)
      total=$((total + $(grep -E -c "$re" /root/.ssh/authorized_keys || echo 0)))
    fi
  fi
  
  echo "$total"
  (IFS=:; echo "${files[*]}")
}

configure_ssh_settings() {
  echo ""
  echo "SSH Configuration"
  echo "────────────────────────────────────────"
  
  # Find available keys
  read -r key_count key_files <<<"$(find_ssh_keys)"
  
  if [[ "$key_count" -gt 0 ]]; then
    echo "Found $key_count SSH key(s) on host"
    echo ""
    echo "Select SSH setup:"
    echo "  1) Use found keys (${key_count} key(s))"
    echo "  2) Enter key manually"
    echo "  3) Password only (no SSH keys)"
    echo ""
    read -p "Choice [1-3]: " ssh_choice
    
    case "$ssh_choice" in
      1)
        SSH_KEYS_FILE="$(mktemp)"
        IFS=: read -ra files <<<"$key_files"
        for f in "${files[@]}"; do
          ssh_extract_keys_from_file "$f" >> "$SSH_KEYS_FILE"
        done
        sort -u -o "$SSH_KEYS_FILE" "$SSH_KEYS_FILE"
        SSH_ENABLED="yes"
        msg_ok "Will use $key_count SSH key(s)"
        ;;
      2)
        echo ""
        echo "Paste SSH public key (ssh-rsa, ssh-ed25519, etc.):"
        read -r manual_key
        if [[ -n "$manual_key" ]]; then
          SSH_KEYS_FILE="$(mktemp)"
          echo "$manual_key" > "$SSH_KEYS_FILE"
          SSH_ENABLED="yes"
          msg_ok "Manual SSH key added"
        fi
        ;;
      3)
        SSH_ENABLED="no"
        msg_ok "SSH keys disabled, password only"
        ;;
    esac
  else
    echo "No SSH keys found on host"
    echo ""
    read -p "Enter SSH public key manually? [y/N]: " manual
    if [[ "$manual" =~ ^[Yy] ]]; then
      echo "Paste SSH public key:"
      read -r manual_key
      if [[ -n "$manual_key" ]]; then
        SSH_KEYS_FILE="$(mktemp)"
        echo "$manual_key" > "$SSH_KEYS_FILE"
        SSH_ENABLED="yes"
        msg_ok "Manual SSH key added"
      fi
    else
      SSH_ENABLED="no"
      msg_ok "SSH keys disabled, password only"
    fi
  fi
  
  echo ""
}

install_ssh_keys_into_ct() {
  local ctid="$1"
  
  [[ "$SSH_ENABLED" != "yes" ]] && return 0
  [[ ! -s "$SSH_KEYS_FILE" ]] && return 0
  
  msg_info "Installing SSH keys into CT $ctid"
  
  pct exec "$ctid" -- bash -c 'mkdir -p /root/.ssh && chmod 700 /root/.ssh' || {
    msg_err "Failed to create /root/.ssh"
    return 1
  }
  
  if pct push "$ctid" "$SSH_KEYS_FILE" /root/.ssh/authorized_keys >/dev/null 2>&1; then
    :
  else
    pct exec "$ctid" -- bash -c "cat > /root/.ssh/authorized_keys" <"$SSH_KEYS_FILE" || {
      msg_err "Failed to write authorized_keys"
      return 1
    }
  fi
  
  pct exec "$ctid" -- bash -c 'chmod 600 /root/.ssh/authorized_keys' || true
  
  msg_ok "SSH keys installed into CT $ctid"
  
  # Cleanup temp file
  [[ -n "$SSH_KEYS_FILE" && -f "$SSH_KEYS_FILE" ]] && rm -f "$SSH_KEYS_FILE"
  
  return 0
}

# ---------- guards ----------
require_root(){ if [[ $(id -u) -ne 0 ]]; then msg_err "Run as root on Proxmox host"; exit 1; fi; }
require_pve(){ command -v pveversion >/dev/null || { msg_err "Run on Proxmox VE host"; exit 1; }; }

# ---------- whiptail wrappers ----------
ask_input(){ local title="$1" def="$2"; whiptail --inputbox "$title" 10 60 "$def" 3>&1 1>&2 2>&3; }
ask_password(){ local title="$1"; whiptail --passwordbox "$title" 10 60 3>&1 1>&2 2>&3; }
ask_yesno(){ local title="$1"; whiptail --yesno "$title" 10 60; }

# ---------- storage selection ----------
select_storage(){
  local class="$1" content="rootdir" label="Container"; [[ "$class" == "template" ]] && { content="vztmpl"; label="Template"; }
  local map opts=() name info
  while read -r name _ _ _ used avail _; do
    [[ -z "$name" ]] && continue
    info="Free: ${avail}K  Used: ${used}K"
    opts+=("$name" "$info")
  done < <(pvesm status -content "$content" | awk 'NR>1')

  if ((${#opts[@]}==2)); then echo "${opts[0]}"; return 0; fi
  whiptail --title "Select $label storage" --menu "Storage for $label" 16 60 6 "${opts[@]}" 3>&1 1>&2 2>&3
}

# ---------- template handling ----------
ensure_template(){
  local storage="$1" url="$2" filename path
  filename="$(basename "$url")"

  # Try to resolve target path for template
  path="$(pvesm path "${storage}:vztmpl/${filename}" 2>/dev/null || true)"
  if [[ -z "$path" ]]; then
    # Fallback to default cache path
    path="/var/lib/vz/template/cache/${filename}"
  fi

  if [[ -f "$path" ]]; then
    msg_ok "Template already present: $filename"
    return 0
  fi

  msg_info "Downloading template: $url"
  wget -q --show-progress -O "$path" "$url" || { msg_err "Download failed"; exit 1; }
  msg_ok "Template downloaded"
  
  # Patch template to include /etc/network/interfaces
  msg_info "Patching template..."
  local tmpdir extractdir
  tmpdir="$(mktemp -d)"
  extractdir="$tmpdir/rootfs"
  mkdir -p "$extractdir"
  
  tar -xf "$path" -C "$extractdir"
  mkdir -p "$extractdir/etc/network"
  cat > "$extractdir/etc/network/interfaces" <<'EOF'
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet dhcp
EOF
  
  # Repack the template
  tar -C "$extractdir" -cJf "$path.tmp" .
  mv "$path.tmp" "$path"
  rm -rf "$tmpdir"
  msg_ok "Template patched"
  
  echo "$filename"
}

patch_template_interfaces(){
  local tarball="$1"

  # Ensure /etc/network/interfaces exists in template (PVE post_create_hook requirement)
  if tar -tf "$tarball" | grep -Eq '(^|/)etc/network/interfaces$'; then
    return 0
  fi

  msg_warn "Template lacks /etc/network/interfaces, patching..."
  local tmpdir
  tmpdir="$(mktemp -d)"
  tar -xf "$tarball" -C "$tmpdir"
  mkdir -p "$tmpdir/etc/network"
  cat >"$tmpdir/etc/network/interfaces" <<'EOF'
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet dhcp
EOF
  tar --numeric-owner -C "$tmpdir" -cJf "$tarball" .
  rm -rf "$tmpdir"
  msg_ok "Patched template with minimal /etc/network/interfaces"
}

# ---------- pct helpers ----------
create_ct(){
  local ctid="$1" tmpl_storage="$2" tmpl_file="$3" container_storage="$4" opts=()
  opts+=("-arch" "armhf")
  opts+=("-hostname" "$HN")
  opts+=("-cores" "$CORE_COUNT")
  opts+=("-memory" "$RAM_SIZE")
  opts+=("-swap" "$SWAP_SIZE")
  opts+=("-rootfs" "${container_storage}:${DISK_SIZE}")
  opts+=("-unprivileged" "1")
  opts+=("-ostype" "debian")
  opts+=("-features" "nesting=1")
  opts+=("-net0" "name=eth0,bridge=${BRG},ip=${NET}")
  [[ -n "$PW" ]] && opts+=("-password" "$PW")

  msg_info "Creating CT $ctid"
  pct create "$ctid" "${tmpl_storage}:vztmpl/${tmpl_file}" "${opts[@]}"
  msg_ok "CT $ctid created"

  # Copy QEMU ARM emulator into container for armhf architecture
  if [[ "${opts[*]}" =~ "-arch armhf" ]]; then
    msg_info "Installing QEMU ARM emulator into container"
    pct mount "$ctid"
    cp -f /usr/bin/qemu-arm-static "/var/lib/lxc/${ctid}/rootfs/usr/bin/" 2>/dev/null || true
    pct unmount "$ctid"
    msg_ok "QEMU ARM emulator installed"
  fi
}

wait_net(){
  local id="$1"
  msg_info "Waiting for network (CT $id)"
  
  # Ensure DHCP client runs
  pct exec "$id" -- bash -c "dhclient eth0 2>/dev/null || true" || true
  
  for attempt in {1..30}; do
    ip=$(pct exec "$id" -- hostname -I 2>/dev/null | awk '{print $1}') || true
    if [[ -n "$ip" ]]; then
      msg_ok "IP: $ip"
      # Test internet connectivity
      if pct exec "$id" -- ping -c 1 8.8.8.8 >/dev/null 2>&1; then
        msg_ok "Internet connectivity confirmed"
        return 0
      fi
    fi
    sleep 2
  done
  
  msg_err "Failed to get network connectivity after 60 seconds"
  msg_warn "Container may not have internet access"
  return 1
}

post_customize(){
  local id="$1"
  
  msg_info "Updating package lists..."
  pct exec "$id" -- bash -c "apt-get update"
  
  msg_info "Installing base packages (this may take 5-10 minutes on ARM emulation)..."
  echo "  → Installing: curl wget gnupg ca-certificates sudo mc"
  pct exec "$id" -- bash -c "DEBIAN_FRONTEND=noninteractive apt-get install -y curl wget gnupg ca-certificates sudo mc"
  msg_ok "Base packages installed"

  msg_info "Adding Wiren Board repository..."
  # Add repo without GPG key (trusted=yes) - WB repo doesn't have valid GPG key URL
  pct exec "$id" -- bash -c "echo 'deb [trusted=yes] http://deb.wirenboard.com/wb7/bullseye stable main' > /etc/apt/sources.list.d/wirenboard.list"
  pct exec "$id" -- bash -c "apt-get update"
  msg_ok "Wiren Board repo added"

  msg_info "Installing WB UI and SSH (this may take 10-15 minutes)..."
  echo "  → Installing: wb-mqtt-homeui openssh-server"
  pct exec "$id" -- bash -c "DEBIAN_FRONTEND=noninteractive apt-get install -y wb-mqtt-homeui openssh-server"
  msg_ok "WB packages installed"

  msg_info "Configuring services..."
  pct exec "$id" -- systemctl mask wb-hwconf-manager wb-mqtt-nm-helper wb-gsm wb-systime-adjust wb-usb-otg wb-modules 2>/dev/null || true
  pct exec "$id" -- systemctl enable ssh 2>/dev/null || true
  pct exec "$id" -- systemctl restart ssh 2>/dev/null || true
  
  # Install SSH keys if configured
  install_ssh_keys_into_ct "$id"
  
  # Install SSH keys if configured
  install_ssh_keys_into_ct "$id"
  
  msg_info "Configuring console access..."
  # Note: When no password is set during pct create, LXC automatically enables
  # password-less console login. We just need to ensure getty is enabled.
  pct exec "$id" -- bash -c '
    systemctl enable console-getty.service 2>/dev/null || true
    systemctl restart console-getty.service 2>/dev/null || true
  '
  msg_ok "Console access configured (password-less login via Proxmox console)"

  msg_ok "Customization complete"
}

# ---------- public entry ----------
run_build(){
  require_root; require_pve
  header_info "$APP"

  NEXTID=$(pvesh get /cluster/nextid)
  local mode
  mode=$(whiptail --title "${APP} LXC" --menu "Select mode" 12 60 3 \
    "default" "Quick install" \
    "advanced" "Edit resources" \
    "exit" "Quit" 3>&1 1>&2 2>&3) || exit 0

  CTID="$NEXTID"
  HN="${APP,,}-wb"
  CORE_COUNT=${CORE_COUNT:-2}
  RAM_SIZE=${RAM_SIZE:-2048}
  SWAP_SIZE=${SWAP_SIZE:-2048}
  DISK_SIZE=${DISK_SIZE:-6}
  BRG=${BRG:-vmbr0}
  NET=${NET:-dhcp}
  PW=""

  if [[ "$mode" == "advanced" ]]; then
    CTID=$(ask_input "Container ID" "$CTID")
    HN=$(ask_input "Hostname" "$HN")
    CORE_COUNT=$(ask_input "vCPUs" "$CORE_COUNT")
    RAM_SIZE=$(ask_input "RAM MB" "$RAM_SIZE")
    SWAP_SIZE=$(ask_input "SWAP MB" "$SWAP_SIZE")
    DISK_SIZE=$(ask_input "Disk GB" "$DISK_SIZE")
    BRG=$(ask_input "Bridge" "$BRG")
    NET=$(ask_input "IPv4 (dhcp or CIDR,gw=x.x.x.x)" "$NET")
    if ask_yesno "Set root password?"; then PW=$(ask_password "Root password"); fi
  fi

  # Configure SSH (replaces old SSH_PUB manual entry)
  configure_ssh_settings

  local tmpl_storage container_storage
  tmpl_storage=$(select_storage template) || exit 1
  container_storage=$(select_storage container) || exit 1

  ensure_template "$tmpl_storage" "$TEMPLATE_URL"
  TEMPLATE="$(basename "$TEMPLATE_URL")"
  create_ct "$CTID" "$tmpl_storage" "$TEMPLATE" "$container_storage"
  pct start "$CTID"
  
  if ! wait_net "$CTID"; then
    msg_err "Network setup failed. Please check container network configuration manually."
    msg_info "To debug: pct enter $CTID, then run: dhclient eth0 && ping 8.8.8.8"
    exit 1
  fi
  
  post_customize "$CTID"
  description "$CTID"
}

# default description impl (override if needed)
description(){
  local id="$1" ip
  ip=$(pct exec "$id" -- hostname -I | awk '{print $1}') || true
  pct set "$id" -description "<p><b>${APP}</b> (WB bullseye armhf)<br>IP: ${ip}</p>"
}
